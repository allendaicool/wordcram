#summary A backlog of things to do for WordCram
#labels Phase-Requirements

= Documentation and Examples =

~~Installation documentation (like a standard Processing library)~~

Create more examples into the download, ~~and get them into the
downloads.~~

!JavaDoc!  Put it in the code, ~~and put it in the ant script.  Generate
it into a `reference` folder, with an index.html, per the 
[http://code.google.com/p/processing/wiki/LibraryGuidelines library guidelines]~~.

Generate wiki-page documentation for !WordPlacers, !WordColorers, etc, from javadoc comments?  Auto-deploy them to the wiki svn?

== !WordCrams to Create ==

[http://www.beatleslyricsarchive.com/albums.php Beatles lyrics],
~~[http://www.usconstitution.net/const.txt the US Constitution]~~, 
~~[http://www.census.gov/genealogy/names/names_files.html popular baby names]~~,
[http://www.apache.org/licenses/LICENSE-2.0.html Apache license],
[http://catb.org/esr/writings/cathedral-bazaar/ The Cathedral and the Bazaar],
[http://www.faqs.org/docs/artu/ The Art of Unix Programming]

~~A Blog header from !WordCram's source.  The odd dimensions will be a
good test, and it'll require a text provider that can parse out Java
words (variable names, methods, classes, etc) -- along with 
[http://download.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html java stop words].~~  Throw in the example sketches and wiki pages.  _This is all set,
except it needs a !TextSource for loading a source folder of java files.  Once that's 
in place, the example can be included with the rest of them,
and this can be crossed off._


= Plug-in Improvements =

== Color ==

Pick some really nice default fonts & colors for demos.  Look at
[http://www.colourlovers.com/palette/1281472/Hybrid?widths=1 colourlovers.com].

Colorers something like http://colorschemedesigner.com's Mono(hue),
Complement(hue), Triad(hue, offsetAngle), etc.

== Auto-Angler ==

An auto-angler that decides whether to rotate a word or not, based on
the destination's aspect ratio.  If it's wide & short, longer words
will be horizontal; if it's tall & narrow, longer words will be
vertical.  Short words will be random.
{{{
double aspect = width / height;
double lenPercentile = maxWordLen / thisWordLen;
//...not sure of the math here, work it out
}}}

== Placers ==

A placer that renders bigger words horizontally by weight, and
vertically close to the bottom -- should produce a right triangle w/
the right angle in the bottom left.

== Text Sources ==

new !DeliciousTagsTextLoader(username), new !RssTextLoader(url), ~~new
!HtmlTextLoader(url)~~, new !TwitterStreamTextLoader(twitterer), new
!JavaSourceCodeTextLoader(srcDir)

~~Text parsing options: case-sensitivity, and whether numbers are included.~~

Make a standard text format for saving (and re-loading) Words, so you
can generate your word weights once, and store it (for faster
applets).

= Core Improvements =

== Layout ==

~~Get the words to render closer to where the Placer places them.  Right
now, the PImage the word is rendered to is so large (to account for
rotated words), that there's a lot of background color between the
point and the first pixels of the word.  This makes it harder to
effectively code up a !WordPlacer, and get the output you want.~~
_*DONE:* switched to java.awt.Shapes, which take up minimal room._

~~Move around rendering process -- separate word placement from word
rendering, and render as late as possible.  Cleaner organization, and
will let words be re-colored without being placed again, or re-laid
out without being Shaped again.~~

Keep words from going off-screen.  Scale the window (somehow) to fit words in, when they run off-screen.  There's some basic bounds-checking now, but it could be a lot better.

Try changing the color scheme AFTER rendering it, without totally
re-rendering.  Try re-laying out words with the same settings.

Arbitrary shapes, like tagxedo.com.

== Performance ==

When placing a word, remember which quadrant it's in.  When checking
for colliding words, check the appropriate quadrant first, to speed
things up.

Parameterize minShapeSize.

Give !WordCram a "max number of words to draw" parameter.

== API ==

~~Give !WordCram a fluent builder interface (in addition to the huge one 
already there), with sensible overloads (varargs) and sensible defaults.~~

Add more overloads to the fluent builder API.

Let users pass a destination PGraphics to !WordCram, so it can go to
something other than the host PApplet.

Render transparently, so you can overlay it, or use it as a mask.

Provide a way to print out the config: font, hues, etc.  (How should a
custom component display itself?)

Fix up `printSkippedWords`.  Options:
  # Store skipped words EVERY time, and then, when `printSkippedWords` is called, dump out its cache.
  # Rename it so it's clearer that you have to call it BEFORE you call draw.  Javadoc should help.
  # Combo of 1 & 2: when it's off, store skipped words; when it's called, dump whatever cache you have; after that, PRINT skipped words, like it does now.

Add a method to get the Word at the given (x,y) coordinates.  Should probably memoize it. Use a quad-tree, or something similar?  That's a bigger change, and it'll mean a very different implementation for this method, but it would probably speed it up.  Trading off (internal) complexity and RAM against speed.

Provide a way to set/get properties on Words, so you don't _have_ to sub-class Word for simple things.

= Building !WordCram =

~~GZip the tar downloads.~~